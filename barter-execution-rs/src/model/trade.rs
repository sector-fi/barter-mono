use super::order::OrderId;
use barter_integration::model::{
    instrument::{symbol::Symbol, Instrument},
    Side,
};
use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};

/// Normalised Barter private [`Trade`] model.
#[derive(Clone, PartialEq, PartialOrd, Debug, Deserialize, Serialize)]
pub struct Trade {
    pub id: TradeId,
    pub time: DateTime<Utc>,
    pub order_id: OrderId,
    pub instrument: Instrument,
    pub side: Side,
    pub price: f64,
    pub quantity: f64,
    pub fees: Fees,
}

/// Private [`Trade`] identifier generated by an exchange. Cannot assume this is unique across each
/// [`Exchange`](barter_integration::model::Exchange),
/// [`Market`](barter_integration::model::Market), or
/// [`Instrument`](barter_integration::model::Instrument).
#[derive(Clone, Eq, PartialEq, Ord, PartialOrd, Hash, Debug, Deserialize, Serialize)]
pub struct TradeId(pub String);

impl<S> From<S> for TradeId
where
    S: Into<String>,
{
    fn from(id: S) -> Self {
        Self(id.into())
    }
}

/// [`Trade`] fees denominated in a [`Symbol`].
#[derive(Clone, PartialEq, PartialOrd, Debug, Deserialize, Serialize)]
pub struct SymbolFees {
    pub symbol: Symbol,
    pub fees: f64,
}

impl SymbolFees {
    /// Construct a new [`SymbolFees`].
    pub fn new<S>(symbol: S, fees: f64) -> Self
    where
        S: Into<Symbol>,
    {
        Self {
            symbol: symbol.into(),
            fees,
        }
    }
}

impl From<SymbolFees> for Fees {
    fn from(fees: SymbolFees) -> Self {
        Self {
            exchange: Some(fees),
            slippage: None,
            network: None,
        }
    }
}

/// Communicative type alias for Fee amount as f64.
pub type FeeAmount = f64;

// Todo: where should the fee currency type / conversion live?
/// All potential fees incurred by a [`FillEvent`].
#[derive(Clone, PartialEq, PartialOrd, Debug, Default, Deserialize, Serialize)]
pub struct Fees {
    /// Fee taken by the exchange/broker (eg/ commission).
    pub exchange: Option<SymbolFees>,
    /// Order book slippage modelled as a fee.
    pub slippage: Option<SymbolFees>,
    /// Fee incurred by any required network transactions (eg/ GAS).
    pub network: Option<SymbolFees>,
}

impl Fees {
    pub fn new_ex<S>(symbol: S, fee: f64) -> Self
    where
        S: Into<Symbol>,
    {
        Self {
            exchange: Some(SymbolFees::new(symbol, fee)),
            slippage: None,
            network: None,
        }
    }

    pub fn new_all<S>(symbol: S, fee: f64) -> Self
    where
        S: Into<Symbol> + Clone,
    {
        Self {
            exchange: Some(SymbolFees::new(symbol.clone(), fee)),
            slippage: Some(SymbolFees::new(symbol.clone(), fee)),
            network: Some(SymbolFees::new(symbol.clone(), fee)),
        }
    }

    /// Calculates the sum of every [FeeAmount] in [Fees].
    pub fn calculate_total_fees(&self) -> f64 {
        // Todo currency conversion?
        self.exchange.as_ref().map(|f| f.fees).unwrap_or(0.0)
            + self.network.as_ref().map(|f| f.fees).unwrap_or(0.0)
            + self.slippage.as_ref().map(|f| f.fees).unwrap_or(0.0)
    }
}
